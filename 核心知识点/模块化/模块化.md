## CommonJs规范
+ CommonJs规范规定，每个模块都是Module对象实例。module长这样
```js
module = {
  id: // 模块id，一般为带有绝对路径的模块文件名
  filename: // 模块文件名，带有绝对路径
  loaded: Boolean // 布尔值 表示模块是否已经加载完成
  parent: Object // 对象 表示调用该模块的模块对象
  children: Array // 数组 表示该模块下调用了那些模块
  exports: Object // 表示该模块对外输出的值 
}
```
+ module.exports是对外的接口，require加载模块其实就是加载module.exports的内容。如
```js
const utilFn = () => {}
module.exports = {
  utilFn,
  ...
}
const getModule = require('./utils.js') 
```
+ 为了方便，Node为每个模块提供了exports变量，指向module.exports,可以对exports进行操作，但是如果对exports 重新赋值则无效
```js
const name = 'fhh'
const obj = {}
const getName = function () {
  console.log(name)
  return name
}
module.exports = {
  name, obj, getName
}
// 可以使用
exports.name = 'chang'

// 重新赋值无效, 依旧以module.exports 为准
exports = {
  newName: 'new'
}
```
+ CommonJS模块首次执行后会缓存这个模块
+ CommonJS模块输出的是值的拷贝
a.js
```js

const name = 'fhh'
setTimeout(() => {
  name = 'change'
})
module.exports = {
  name 
}
```
b.js
```js
const name = require('./a.js')
console.log(name) // fhh
```
## ES6 modules规范
+ export 做导出，import做导入
```js
// 导出
export default test
export const name
export function fn(){}
export { name, fn }
export * from 
// 导入
import test from './test.js'
import './test.js' // 引人模块，会执行里面的内容，但没有引人模块中导出的内容
import * as test from 'test.js' // 引人整个模块，重命名为test
import { name } from 'test.js' // 引人整个模块的name变量
import { name as newName } from 'test.js' // 引人test模块 name变量，并重命名为 newName
import test, { name } from 'test.js' // 引人test整个模块 和 name变量
```
+ export 输出的是值的引用
```js
```
+ import只能在模块的顶层，不能在函数、或判断语句中引用
+ import不能对引人模块重新赋值和定义
### 优点
+ 静态import能确保被编译成变量引用
+ 静态export能让变量检测更准确
+ 更完备的循环依赖出
## Es6模块与CommonJS模块的差异
+ ES6模块是编译时加载，CommonJS模块是运行时加载，即 esModule可以在import引用语句之前使用模块，CommonJS则需要先引用后才能使用
+ ES6模块输出的是值的引用，CommonJS模块输出的是值的拷贝
```js

```
+ import引人的对象被修改时，源对象也会被修改，相当于浅拷贝，require引人的对象被修改时，源对象不会被修改，可以理解为深拷贝
+ import有利于tree-shaking
+ import只能在模块的顶层使用，不能在函数或判断语句中使用，require可以
+ import不能对引人模块重新赋值和定义