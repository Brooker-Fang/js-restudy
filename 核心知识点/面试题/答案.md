## promise
```js
```
## 手写new
```js
function Person() {
  this.name = 'person'
}
Person.prototype.getName = function() {
  return this.name
}
function myNew(fn, ...args) {
  let obj = Object.create(fn.prototype)
  let res = fn.call(obj, ...args)
  return res !== null && res instanceof Object ? res : obj
}
let p = new Person()
console.log(p.getName())
let p2 = myNew(Person)
console.log(p2, p2.getName())
```
## 手写instanceof
```js
function myInstanceof(left, right) {
  let leftPrototype = left.__proto__
  let rightPrototype = right.prototype
  while(leftPrototype) {
    if(leftPrototype === rightPrototype) {
      return true
    }
    leftPrototype = leftPrototype.__proto__
  }
  return false
}
```
## 手写bind、apply、call
```js
let obj = {name: 'obj'}
function getName() {
  console.log(this.name)
}
function myCall(context, ...args){
  context = context || window
  let sym = Symbol('fn')
  context[sym] = this
  context[sym](...args)
  delete context[sym]
}
function myBind(context, ...baseArgs) {
  const ctx = context || window
  const fn = this
  const bound = function(...args) {
    return fn.apply(this instanceof bound ? this : ctx, [...baseArgs, ...args])
  }
  const noop = function() {}
  noop.prototype = this.prototype
  bound.prototype = new noop()
  return bound
}
function Person(name, age) {
  this.name = name
  this.age = age
}
let obj = {}
let nPerson = Person.bind(obj, name)
let obj2 = new nPerson(18)
console.log(obj, obj2)
```
## 遍历对象的方法
for ... in : 循环遍历对象自身的和继承的可枚举属性
Object.keys(): 遍历自身属性，返回数组key，不包含继承，不包含Symbol
Object.getOwnPropertyNames(obj): 返回数组key，包含不可枚举属性，不包含Symbol
Reflect.ownKeys(obj): 返回数组，包含所有属性，包含Symbol 和不可枚举属性
```js
class Person {
  type = 'type'
}
class Man extends Person{
  constructor(props) {
    super(props)
    this.name = 'man'
  }
}
let man = new Man()
man[Symbol('sym')] = 'sym'
Object.defineProperty(man, 'canRead', {
  value: true,
  enumerable: false
})
console.log(man)
for(let key in man) {
  console.log(key)
}
console.log('Object.keys===', Object.keys(man))
console.log('Object.getOwnPropertyNames===', Object.getOwnPropertyNames(man))
console.log('Reflect.ownKeys===', Reflect.ownKeys(man))
```
## 手写深复制
```js

function deepClone(obj, wMap = new WeakMap()) {
  if (obj === null || typeof obj !== 'object' ) return obj
  if(wMap.has(obj)) {
    return wMap.get(obj)
  }
  let nObj = new obj.constructor()
  wMap.set(obj, nObj)
  Reflect.ownKeys(obj).forEach(key => {
    if(obj.hasOwnProperty(key)) {
      nObj[key] = deepClone(obj[key], wMap)
    }
  })
  return nObj
}
let obj = {
  name: 'obj',
  obj: {
    name: 'obj2',
    obj: {
      name: 'obj3',
    }
  },
  [Symbol('sym')]: 'sym'
}
obj.myObj = obj
let nObj = deepClone(obj)
console.log(nObj)
```
## 手写数组扁平化
```js
const arr = [[1,2], [[3],4,[[[5]]]]]
function flat(arr) {
  return arr.reduce((prev, current) => {
    return 
  }, [])
}
const arr2 = flat(arr)
```
## 手写柯里化
```js
function sumFn(a,b,c){return a+ b + c};
let sum = curry(sumFn);
sum(2)(3)(5)//10
sum(2,3)(5)//10
function curry(fn, ...args) {
  let fnLen = fn.length
  let argsLen = args.length
  if(fnLen > argsLen) {
    return function(...args2) {
      return curry(fn, ...args, ...args2)
    }
  } else {
    fn(...args)
  }
}
```
## css画三角形
```html
<style>

.circle{
  width:0;
  height: 0;
  border-top: 10px solid black;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
}
</style>
```
## jsonp原理实现
```js
JSONP({
    url: 'http://localhost:8080/api/jsonp',
    params: { id: 1 },
    callbackKey: 'cb',
    callback (res) {
        console.log(res) // No.1
    }
})
function JSONP({url, params, callback}) {
  let callbackId = JSONP.callbackId || 1
  let callbacks = JSONP.callbacks || []
  callbacks[callbackId] = callback
  params.cb = `JSON.callbacks[${callbackId}]`
  let paramsString = Object.keys(params).reduce((key, index) => {
    return index > 0? '&' : '?' + key + '=' + params[key]
  }, '')
  let script = document.createElement('script')
  script.setAttribute('src', paramsString)
  document.body.appendChild(script)
}
```

## 防抖
```js
function debounce(fn, wait, immediate) {
  let timer = null
  return function(...args) {
    let self = this
    if(immediate) {
      timer = setTimeout(() => {
        timer = null
        fn.call(self, ...args)
      })
    } else {
      timer && clearTimeout(timer)
      setTimeout(() => {
        fn.call(self, ...args)
      })
    }
  }
}
```
## 节流
```js
function throttle(fn, wait) {
  let lastTime = null
  return function(...args) {
    let now = +new Date()
    let self = this
    if(!lastTime || now - lastTime > wait) {
      
      fn.call(self, ...args)
      lastTime = now
    } 
  }
}
```