## promise
```js
```
## 手写new
```js
function Person() {
  this.name = 'person'
}
Person.prototype.getName = function() {
  return this.name
}
function myNew(fn, ...args) {
  let obj = Object.create(fn.prototype)
  let res = fn.call(obj, ...args)
  return res !== null && res instanceof Object ? res : obj
}
let p = new Person()
console.log(p.getName())
let p2 = myNew(Person)
console.log(p2, p2.getName())
```
## 手写instanceof
```js
function myInstanceof(left, right) {
  let leftPrototype = left.__proto__
  let rightPrototype = right.prototype
  while(leftPrototype) {
    if(leftPrototype === rightPrototype) {
      return true
    }
    leftPrototype = leftPrototype.__proto__
  }
  return false
}
```
## 手写bind、apply、call
```js
let obj = {name: 'obj'}
function getName() {
  console.log(this.name)
}
function myCall(context, ...args){
  context = context || window
  let sym = Symbol('fn')
  context[sym] = this
  context[sym](...args)
  delete context[sym]
}
function myBind(context, ...baseArgs) {
  const ctx = context || window
  const fn = this
  const noop = function() {}
  noop.prototype = this.prototype
  bound.prototype = new noop()
  const bound = function(...args) {
    return fn.apply(this instanceof bound ? this : ctx, [...baseArgs, ...args])
  }
  return bound
}
function Person(name, age) {
  this.name = name
  this.age = age
}
let obj = {}
let nPerson = Person.bind(obj, name)
let obj2 = new nPerson(18)
console.log(obj, obj2)
```
## 遍历对象的方法
for ... in : 循环遍历对象自身的和继承的可枚举属性
Object.keys(): 遍历自身属性，返回数组key，不包含继承，不包含Symbol
Object.getOwnPropertyNames(obj): 返回数组key，包含不可枚举属性，不包含Symbol
Reflect.ownKeys(obj): 返回数组，包含所有属性，包含Symbol 和不可枚举属性
```js
class Person {}
Person.prototype.type = 'type'
class Man extends Person{
  constructor(props) {
    super(props)
    this.name = 'man'
  }
}
let man = new Man()
man[Symbol('sym')] = 'sym'
Object.defineProperty(man, 'canRead', {
  value: true,
  enumerable: false
})
console.log(man)
for(let key in man) {
  console.log(key)
}
console.log(Object.keys(man))
```
## 手写深复制
```js
let obj = {
  name: 'obj',
  obj: {
    name: 'obj2',
    obj: {
      name: 'obj3'
    }
  }
}
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object' ) return obj
  let nObj = {}
  for(let key in obj) {
    if()
  }
  return nObj
}
```
## 手写数组扁平化
```js
```
## 手写柯里化
```js
```
## css画三角形
## jsonp原理实现
```js
```