https://juejin.cn/post/6844904083707396109#heading-48

面经：
https://www.yuque.com/docs/share/2fa704d6-d51b-41dd-bf3d-d1152c06a0c1
https://juejin.cn/post/6844904151369908232
复习文章：
https://mp.weixin.qq.com/s/rNv8K3SYrEvo4PIHCwMnLw
https://juejin.cn/post/6844904116339261447#heading-49
js基础：
https://mp.weixin.qq.com/s/-2988ihLNWvCgnCgoapS4g
vue：
https://juejin.cn/post/6930897845369356295
https://mp.weixin.qq.com/s/8RJGp9M9yNx-LMcN5q8gUQ
webpack：
https://juejin.cn/post/6844904094281236487#heading-16
## 原生的自定义事件
3中方式：
1、new Event
```js
let myEvent = new Event('myEvent')
```
2、new customEvent
```js
let myEvent = new CustomEvent('myEvent', {
  detail: {

  }
})
```
3、document.createEvent 和 initEvent
createEvent: 创建事件
initEvent：初始化事件
addEventListener: 监听事件
dispatchEvent(event_name): 触发事件
```js
let myEvent = document.createEvent('myEvent')
/* params
  1. event_name: 事件名称
	2. canBubble: 是否冒泡
	3. cancelable: 是否可以取消默认行为
*/
myEvent.init('myEvent', true, true)
dom.addEventListener('myEvent', () => {
  console.log('myEvent')
})
dom.dispatchEvent(myEvent)
```

## 为什么浏览器会禁止跨域？
跨域是因为浏览器的同源策略，同源即 相同的协议、域名、端口，只有同源才能访问相同的cookie和localStorage

## CORS跨域的原理
实现cors的关键是服务器，只要服务器实现了cors接口，就可以跨源通信。
cors分为简单请求和非简单请求，
简单请求要满足两个条件： 
1、请求方法是get、post、head 其中一种
2、http头信息不超出以下几种字段：
  accept
  accept-language
  content-language
  last-event-id
  content-type只限于3种值：application/x-www-form-urlencoded,multipart/form-data，text/plain

简单请求的流程：
浏览器在请求头加了origin字段，由服务端去判断 这个origin指定的源 是否在允许的 源范围内

非简单请求：
非简单请求时那种对服务端有特殊要求的请求，如put、delete。或者Content-type 为 application/json
非简单请求流程：
会发起两个http请求，第一个是预检请求，请求方法是options，用来询问该origin指定的源 是否在允许跨源范围内，得到允许跨域的回复后，
浏览器才会发出正式的XMLHttpRequest请求

## 实现跨域的方法
jsonp，但只支持get请求
cors，需要服务端配置

## CommonJS和ES6模块的区别

## 怎么实现一组异步请求按顺序执行
1、reduce 配合 promise
使用Promise实现每隔1秒输出1,2,3
```js
const arr = [1, 2, 3]
arr.reduce((p, x) => {
  return p.then(() => {
    return new Promise(res => {
      setTimeout(() => {
        res(console.log(x))
      }, 1000)
    })
    
  })
}, Promise.resolve())
```
2、for...await...of

## 为什么0.1 + 0.2 !== 0.3
js里的数字64位浮点数，尾数52位，而计算机存储时会把尾数超过52位的部分截取掉，0.1和0.2转为二进制会出现无限循环，最终超过的位数会被截取掉，所以导致计算不精确.
解决：使用第三方库，bignumber，Math.js