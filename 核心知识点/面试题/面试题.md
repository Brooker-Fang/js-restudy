面经：
https://www.yuque.com/docs/share/2fa704d6-d51b-41dd-bf3d-d1152c06a0c1
https://juejin.cn/post/6844904151369908232
https://mp.weixin.qq.com/s/D6zTSh_szw4uhk3eqkiBPA
https://mp.weixin.qq.com/s/H9zL3Luy0G6fYAx7aNzwmg
https://vue3js.cn/interview/
https://mp.weixin.qq.com/s/rlq-BwF9XkkibPAG5W17Kg
复习文章：
https://mp.weixin.qq.com/s/rNv8K3SYrEvo4PIHCwMnLw
https://juejin.cn/post/6844904116339261447#heading-49
https://mp.weixin.qq.com/s/W6bsZjrVZDEiIGVd8ACFig
https://github.com/haizlin/fe-interview
js基础：
https://muyiy.cn/question/js/4.html
https://github.com/qappleh/Interview/issues?page=16&q=is%3Aissue+is%3Aopen
https://mp.weixin.qq.com/s/-2988ihLNWvCgnCgoapS4g
this面试题： https://juejin.cn/post/6844904083707396109#heading-48
vue：
https://juejin.cn/post/6930897845369356295
https://mp.weixin.qq.com/s/8RJGp9M9yNx-LMcN5q8gUQ
webpack：
https://juejin.cn/post/6844904094281236487#heading-16
## 原生的自定义事件
3中方式：
1、new Event
```js
let myEvent = new Event('myEvent')
```
2、new customEvent
```js
let myEvent = new CustomEvent('myEvent', {
  detail: {

  }
})
```
3、document.createEvent 和 initEvent
createEvent: 创建事件
initEvent：初始化事件
addEventListener: 监听事件
dispatchEvent(event_name): 触发事件
```js
let myEvent = document.createEvent('myEvent')
/* params
  1. event_name: 事件名称
	2. canBubble: 是否冒泡
	3. cancelable: 是否可以取消默认行为
*/
myEvent.init('myEvent', true, true)
dom.addEventListener('myEvent', () => {
  console.log('myEvent')
})
dom.dispatchEvent(myEvent)
```

## 为什么浏览器会禁止跨域？
跨域是因为浏览器的同源策略，同源即 相同的协议、域名、端口，只有同源才能访问相同的cookie和localStorage

## CORS跨域的原理
实现cors的关键是服务器，只要服务器实现了cors接口，就可以跨源通信。
cors分为简单请求和非简单请求，
简单请求要满足两个条件： 
1、请求方法是get、post、head 其中一种
2、http头信息不超出以下几种字段：
  accept
  accept-language
  content-language
  last-event-id
  content-type只限于3种值：application/x-www-form-urlencoded,multipart/form-data，text/plain

简单请求的流程：
浏览器在请求头加了origin字段，由服务端去判断 这个origin指定的源 是否在允许的 源范围内

非简单请求：
非简单请求时那种对服务端有特殊要求的请求，如put、delete。或者Content-type 为 application/json
非简单请求流程：
会发起两个http请求，第一个是预检请求，请求方法是options，用来询问该origin指定的源 是否在允许跨源范围内，得到允许跨域的回复后，
浏览器才会发出正式的XMLHttpRequest请求

## 实现跨域的方法
jsonp，但只支持get请求
cors，需要服务端配置
postMessage，通过注册监听信息的Message事件、调用发送信息的postMessage方法，可以实现跨窗口通信。

## CommonJS和ES6模块的区别

## 怎么实现一组异步请求按顺序执行
1、reduce 配合 promise
使用Promise实现每隔1秒输出1,2,3
```js
const arr = [1, 2, 3]
arr.reduce((p, x) => {
  return p.then(() => {
    return new Promise(res => {
      setTimeout(() => {
        res(console.log(x))
      }, 1000)
    })
    
  })
}, Promise.resolve())
```
2、for...await...of

## 为什么0.1 + 0.2 !== 0.3
js里的数字64位浮点数，尾数52位，而计算机存储时会把尾数超过52位的部分截取掉，0.1和0.2转为二进制会出现无限循环，最终超过的位数会被截取掉，所以导致计算不精确.
解决：使用第三方库，bignumber，Math.js

## 下面代码打印什么
重点：非匿名自执行函数，函数变量只读不能修改
```js
var b = 10;
(function b() {
   b = 20; 
   console.log(b); // Function b
   console.log(window.b); // 10 
})();
```

```js
var b = 10;
(function b() {
    var b = 20; 
    console.log(b); // 20
   console.log(window.b); // 10 
})();
```

## 输出代码执行结果

```js
var a={}, b='123', c=123;  
a[b]='b';
a[c]='c';  
console.log(a[b]);
```
```js
var a={}, b=Symbol('123'), c=Symbol('123');  
a[b]='b';
a[c]='c';  
console.log(a[b]);
```
```js
var a={}, b={key:'123'}, c={key:'456'};  
a[b]='b';
a[c]='c';  
console.log(a[b]);
```

cbc
+ 对象的键名只能是字符串和Symbol类型，其他类型的键名会被转换为字符串
+ 如果键是对象，则会调用默认的toString，即'[object Object]'

## input怎么处理中文输入

使用compositionstart 和 compositionend事件，可以知道中文输入什么时候开始和结束

##  跨标签页的通讯方式有哪些
https://juejin.cn/post/6844903811232825357#heading-2
+ BroadCast Channel
+ Service Worker
+ LocalStorage, LocalStorage变化时，会触发storage事件，可以监听storage事件

## 什么是内存泄漏？常见原因？怎么排查？怎么解决？
什么是内存泄漏：不在用到的内存，没有及时释放
常见原因：
  + 意外的全局变量
  + 未及时清理的计时器和回调函数
  + 闭包滥用
  + 对象循环引用
解决：
  + 尽量不用全局变量
  + 及时清理计数器和回调函数
  + 使用闭包的时候要注意
  + 使用weakMap、weakSet
排查：浏览器查看内存占用
## 对MVC、MVP、MVVM理解
目标都是为了解决Model和View的耦合问题
MVC：通信是单向的，View传递命令到Controller，Controller完成业务逻辑后，让Model改变状态，Model将改变后的数据发送到View
MVP: 各部分直接的通信都是双向的，View不与Model发生联系，由Presenter传递，解决了MV的耦合问题，但是Presenter过于臃肿导致维护问题
MVVM: 采用双向绑定，view变动会反映给ViewModel，ViewModel改变也会反映在View层，即解决了耦合问题，还保持了可维护性、和不错的性能表现

## image上埋点的优点
+ 没有跨域问题
+ 只需要new Image就能发起请求，不会阻塞页面加载，影响用户的体验
+ 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据