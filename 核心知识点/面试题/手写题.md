https://mp.weixin.qq.com/s/SYcSOqKYE3ldiGhXTkCOHw

## Promise
```js
let p = new Promise((res, rej) => {
  res(1)
}).then(res => {
  console.log(res)
  return 3
}).then(res => {
  console.log(res)
})
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  status = PENDING
  value = undefined
  error = undefined
  successCallback = []
  failCallback = []
  constructor(exec) {
    try {
      exec(this.resolve, this.reject)
    } catch (e) {
      this.reject(e)
    }
  }
  resolve = (val) => {
    if(this.status === PENDING) {
      this.value = val
      this.status = FULFILLED
      // 循环执行成功回调
      while(this.successCallback.length) {
        this.successCallback.shift()()
      }
    }
  }
  reject = (err) => {
    if(this.status === PENDING) {
      this.error = err
      this.status = REJECTED
      // 循环执行成功回调
      while(this.failCallback.length) {
        this.failCallback.shift()()
      }
    }
    return false
  }
  then = (successCallback, failCallback) => {
    successCallback = successCallback ? successCallback : (val) => val
    failCallback = failCallback ? failCallback : (error) => { throw error }
    let p2 = new MyPromise((resolve, reject) => {
      if (this.status === FULFILLED) {
        try {
          let res = successCallback(this.value)
          if(res instanceof MyPromise) {
            res.then(val => resolve(res), err => reject(err))
          } else {
            resolve(res)
          }
        } catch(e) {
          reject(e)
        }
        
      } else if(this.status === REJECTED ){
        try {
          let res = failCallback(this.value)
          if(res instanceof MyPromise) {
            res.then(val => resolve(res), err => reject(err))
          } else {
            resolve(res)
          }
        } catch(e) {
          reject(e)
        }
      } else {
        // 异步执行 此时状态还是PENDING
        this.successCallback.push(() => {
          setTimeout(() => {
            try {
              let res = successCallback(this.value)
              if(res instanceof MyPromise) {
                res.then(val => resolve(res), err => reject(err))
              } else {
                resolve(res)
              }
              
            } catch(e) {
              reject(e)
            }
          })
        })
        this.failCallback.push(() => {
          setTimeout(() => {
            try {
              let res = failCallback(this.value)
              resolve(res)
            } catch(e) {
              reject(e)
            }
          })
        })
      }
    })
    return p2
  }
  catch = (failCallback) => {
    return this.then(undefined, failCallback)
  }
  static resolve = (res) => {
    return new MyPromise((resolve) => resolve(res))
  }
  finally = (cb) => {
    return this.then((val) => {
      return MyPromise.resolve(cb()).then(() => val);
    }, (error) => {
      return MyPromise.resolve(cb()).then(() => { throw error });
    })
  }
  static all = (arr) => {
    let res = []
    let index = 0
    return new MyPromise((resolve, reject) => {
      function addResult(key, val) {
        res[key] = val
        index ++
        if(index === res.length) {
          resolve(res)
        }
      }
      arr.forEach((promise, index) => {
        let curPro = arr[i]
        if(curPro instanceof MyPromise) {
          curPro.then((val) => addResult[i, val], (error) => reject(error))
        } else {
          addResult(i, curPro)
        }
      })
    })
  }
}
let p2 = new MyPromise((res, rej) => {
  res(1)
}).then(res => {
  console.log(res)
  return 3
}).then(res => {
  console.log(res)
})
let p3 = new MyPromise((res, rej) => {
  setTimeout(() => {
    res(1)
  }, 1000)
}).then(res => {
  console.log(res)
  return 3
})
let p4 = MyPromise.resolve(4).then((res) => console.log(res))
let p5 = new MyPromise((res, rej) => {
  res(5)
}).then(res => {
  console.log(res)
}).finally(() => {
  console.log('finally')
})
function allP1 () {
  return new MyPromise((resolve, reject) => {
    setTimeout(() => {
      resolve('all p1 resolve')
    }, 2000)
  })
}
function allP2 () {
  return new MyPromise((resolve, reject) => {
    resolve('all p2 resolve')
  })
}
MyPromise.all(['1', '2', allP1(), allP2(), '3']).then(res => {
  console.log('all res == ', res)
})
```
## 数组去重
```js
let arr = [1,2,1,2,3,3]
arr = [...new Set(arr)]
```
## 手写new

## 手写instanceof
## 手写bind、apply、call
## 寄生式组合继承
## Object.create
## 防抖
## 节流
## EventEmitter实现
## 手写深复制
## 手写数组扁平化
## 手写柯里化
## jsonp原理实现
https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%A8%E5%9F%9F/JSONP%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.md
## 算法
https://juejin.cn/post/6844903582328717325#heading-10
### 冒泡排序

```js
let arr = [3, 2, 1, 7,5,7,9,8, 6]
let len = arr.length
for(let i = 0; i < len; i++) {
  for(let j = i + 1; j < len; j ++) {
    if(arr[i] > arr[j]) {
      let temp = arr[i]
      arr[i] = arr[j]
      arr[j] = temp
    }
  }
}
```
## 二分排序

## 快速排序