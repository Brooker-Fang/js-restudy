## 强缓存和协商缓存
强缓存：
+ 强缓存通过Cache-Control 和 Expires 两个字段实现
+ Expires是http1.0的，表示过期时间
+ Cache-Control是http1.1的，优先级高于Expires
  + request请求相关的缓存指令：
    + max-age：表示存活时间，单位s
    + no-cache：通过协商缓存决定是否使用缓存
    + no-store：所有内容都不会被缓存，包括强缓存和协商缓存
    + min-fresh：能够容忍的最小新鲜度，即 max-age + min-fresh时间内 可以使用缓存
    + max-stale：最大容忍时间，如果没有指定，则说明浏览器愿意接收任何age的响应
  + response响应相关的缓存指令：
    + no-cache
    + no-transform: 告诉中间代理不要改变资源的格式。中间代理有时会改变图片以及文件的格式来提高性能
    + public：客户端和代理服务器都可以缓存
    + private：只有客户端可以缓存
    + max-age
协商缓存：当没有命中强缓存，会发起请求到服务器，如果命中协商缓存则返回304和Not Modified。协商缓存通过Etag/If-None-Match，Last-Modified/If-Modified-Since这俩组实现对比。
  + Last-Modified指资源上次的更新时间，首次请求会返回并保存，下一次请求带上If-Modified-Since，值为Last-Modified，服务端进行比对 资源的更新时间，判断是否命中协商缓存。缺点是：保存的时间只具体到秒，但资源有可能在1s内多次更新
  + Etag是唯一标识的hash值，只要资源发生变化，Etag就会改变。下次请求就带上 If-None-Match：Etag。缺点是：性能较差，每次都要通过算法更新Etag
总结：强制缓存优先于协商缓存，若强制缓存生效则直接使用缓存，不生效则进行协商缓存。强制缓存 由Cache-Control 或 Expires 实现。协商缓存由 Etag/If-None-Match 和 Last-Modified/If-Modified-Since 实现。对于频繁变动的资源，使用协商缓存，对于不常变动的资源，使用强制缓存，如max-age设置很大的时间，然后通过增加版本号，更新资源。
### 缓存位置
缓存位置一般位于Memory cache（内存缓存），disk cache（磁盘缓存）
### 如何不使用缓存
+ Cache-Control：no-store
+ 改变资源的url，如增加版本号、hash值
### no-store和no-cache区别
+ no-store是完全禁止缓存
+ no-cache是协商缓存
## 3次握手建立tcp连接
+ 客户端想要发送数据给服务端之前，必须先在两端之间建立连接
+ 第一次握手，客户处发送标志位syn为1的包，服务器接收到后确认客户端发送正常 和自身接收能力正常。syn即sychronize 意为同步
+ 第二次握手，服务端发送syn-ack返回客户端，客户端确认服务端接收发送能力正常，自身的发送和接收能力也正常。ack即acknowledge，意为确认
+ 第三次握手，客户端ack发送服务端，服务接收到，确认了自身发送能力也正常，和客户端接收能力正常。
+ 至此，客户端和服务端都确认了自身 和 对方的接收发送能力都正常，可以开始进行数据传输了。
+ 所以3次握手主要是确认对端的接收发送能力都没问题
+ 前端性能优化即要减少tcp连接，因为3次握手的时间会带来性能损失
## 四次挥手关闭tcp连接
+ 第一次挥手：客户端要断开连接时，发送一个fin标志为1的包，表示自己已经没有数据可以发送，但仍然可以接收数据
+ 第二次挥手：服务端接收到客户端发送的包，发送一个确认包，表明自己接收到客户端要关闭连接的请求，此时还没有关闭连接
+ 第三层挥手：服务端准备好关闭连接时，会再向客户端发送结束连接请求，
+ 第四层挥手：客户端接收到服务端关闭请求，发送一个确认包，并关闭连接，服务端接收到后，亦关闭连接
## http1.1 与 http1.0区别
+ 缓存处理：1.1使用Etag/If-None-Match等更多缓存头来控制缓存，1.0使用last-modified、Expires
+ 长连接：1.1支持长连接，即在一个tcp连接可以传送多个http请求和响应，Connection：keep-alive
+ 错误状态管理：1.1增加了24个错误状态响应码
+ 其他：新增请求方式，put、delete、options
+ 1.1加入了管道化特性：即允许客户端在已发送的请求收到服务端响应之前发送下一个请求
## http1.1和1.0问题
+ 传输数据都是明文传送，安全性不足
+ 1.0基于tcp协议，要三次握手才能建立连接，每次传输数据都要重新建立连接
+ 1.1虽然支持了长连接，加入了管道化特性，但是还是解决不了队头阻塞问题。
  + 队头阻塞：每个请求响应必须等到前一个请求响应之后才能发送
+ 而且长连接也会影响性能，因为响应之后还保持了不必要的连接很长时间
## https
+ https请求默认使用443端口进行连接
### 加密方式
按照密钥的使用方式，加密可以分为：对称加密和非对称加密、混合加密
对称加密：指加密和解密使用的密钥都是同一个。缺点：在密钥交换时，密钥可能被窃取到，如果密钥被获取了，就失去了机密性
非对称加密：
  有公钥和私钥两个不同的密钥，公钥加密只能私钥解开，私钥加密也只能公钥才能解开。
  缺点是非对称加密需要比较复杂的数学计算，速度很慢
混合加密：即TLS里使用的加密方式。通信开始时先使用非对称加密，解决密钥交换问题。然后使用随机数产生对称算法使用的会话密钥，在用公钥加密，对方拿到密文后私钥解密，取出会话密钥，这样就实现了对称密钥的安全交换，后续就全部使用对称加密
### 摘要
+ 摘要算法是一种单向算法，是把任意长度的数据转为一定长度的数据，并且这个过程不可逆
+ 摘要算法的两个特点：
  + 1、无法通过加密后的数据推算出源数据
  + 2、两份不同的数据加密后一定是不相同的值
### TLS1.2握手过程
+ https协议会先于服务器执行tcp握手，然后执行tls握手，才能建立安全连接
+ 客户端发送tls版本、加密套件列表、客户端随机数client_random（用于后续生成会话密钥）
+ 服务器收到消息后，对一下版本，选择密码套件，也生成一个随机数，然后发送选择的加密套件、服务端随机数server_random、公钥server_params 和 服务器证书
+ 客户端接收到消息后，验证服务器的证书是否真实有效。验证通过传递client_params这个参数给服务端
+ 此时客户端和服务端都有client_params 和 server_params，通过这两个参数，根据ECDHE算法算出pre_master
+ 此时两端也都有了client_random、 server_random、pre_master这三个随机数，根据这三个随机数 生成用于加密的会话密钥，master secret
+ 然后客户端会发给服务端两个收尾消息，一个是Change Cipher Spec，告诉服务器后面都用加密消息，一个是Finished，对之前所有发送的数据做摘要，对摘要进行加密，然后服务器验证
+ 服务端也是同样的操作，发送Change Cipher Spec 和 Finished消息
+ 当双方都验证加密解密Ok，握手正式结束，后面就收发被加密的HTTP请求和响应了

### TLS1.3做了那些改进
+ 主要改进内容：兼容、安全与性能
+ 安全：精简了算法，tls1.3只有5个加密套件，废除了rsa和dh密钥交换算法，保证了前向安全，即后面的密钥被破解了，也没办法破解之前报文的加密内容，因为每次密钥生成都是临时的
+ 性能：比tls1.2版本少了一个RTT，服务端不必等到客户端验证完证书后才拿到client_params,客户端第一次握手时就把client_params发送给服务端，服务端拿到后就可以立即计算出会话密钥，算出密钥后，服务器立即发出Change Cipher Spec 比tls1.2提早进入加密通信

## 中间人攻击
+ 服务器向客户端发送公钥
+ 攻击者截获公钥，保留自己手上
+ 然后攻击者生成伪造的密钥，发给客户端
+ 客户端收到伪造的密钥，生成加密hash值发给服务器
+ 攻击者获得加密hash值，用自己的私钥解密获得真密钥
+ 同时生成假的hash值发给服务器
+ 服务器用私钥解密获得假密钥
+ 服务器用假密钥加密传输信息
## https 与 http1.1区别
+ https是由tls和http协议构建的可进行加密、身份认证的网络协议，比http更安全
+ https需要CA申请证书，大部分证书都需要交费
+ https对访问速度会有一定的降低，因为多了tls握手、大量的密钥算法计算等
## http2.0 新特性
+ 2.0的协议解析采用二进制格式传输数据，1.x是基于文本的，文本表现形式多样，需要考虑较多场景
+ 多路复用，所有请求都是通过一个tcp连接并发完成。因为数据流以消息形式发送，而消息由一个或多个帧组成，每个帧首部会有流的标识，所以多个帧可以乱序发送，通过帧的流标识重新组装
+ 服务端推送，允许服务端对客户端的一个请求发送多个响应，如浏览器只请求了index.html,服务器把index.html、style.css、png一起发送给浏览器，这样只需要一轮http通信，浏览器就得到了全部资源
+ header压缩，http2.0在客户端和服务端使用 首部表来缓存之前发送的键值对，对于相同的头部字段，后续的请求和响应不会重复发送，减小了头部的大小。1.x的header携带的内容过大，而且很多字段又是重复的，如Cookie，增加了传输的成本
+ 主流的浏览器只主持加密的http2
+ 兼容http1.1
## http2.0问题
+ 依旧是要经过tcp连接3次握手 和 tls 连接
+ tcp的队头阻塞并没有彻底解决。因为tcp有个丢包重传机制，http2.0出现丢包时，整个tcp都要开始等待重传，这样就阻塞到该tcp连接中的所有请求。而1.1因为可以开启多个tcp连接，丢包只会影响一个tcp连接

## TCP和UDP区别
+ 连接性：tcp是面向连接的协议，在收发数据前必须先建立可靠的连接，udp是面向无连接的协议，数据传输不需要建立连接
+ 可靠性：tcp提供确保数据不丢失、不重复且按需到达的传输服务，udp使用尽可能最大努力缴费，但不保证可靠交付
+ 报文首部：tcp报文首部有20个字节，额外开销大，udp只有8个字节
+ 传输方式、：tcp面向字节流，将应用层报文看成一串无结构的字节流，分解为多个tcp报文段传输后，在目的站重新装配。udp面向报文，不拆分应用层报文
+ 连接对象个数：tcp只能是一对一通信，udp支持一对一、一对多、多对多
+ 应用场景：tcp适用于要求可靠传输的场景，如文件传输。udp适用于实时应用，如ip电话、视频会议、直播
## http3.0
HTTP3.0的核心是QUIC协议，可以定义为基于UDP的安全可靠的HTTP2.0协议。
QUIC协议针对基于TCP和TLS的HTTP2.0协议，解决了几个问题
+ 减少了tcp三次握手和tls握手时间。基于UDP协议的QUIC，因为UDP本身没有连接的概念，连接建立时只需要一次交互的时间

## 怎么理解http是无状态的
+ 无状态指协议对于事务处理没有记忆能力，每个请求都是独立的，不涉及状态变更。
+ 优点：解放服务端压力，不会造成不必要的连接占用
+ 缺点：缺少对状态的保存，如果后续需要处理前面的信息，就必须重传，导致每次传送的数据量增大
+ 解决方案：使用cookie和session

## Cookie
+ Cookie是浏览器访问服务器后，服务器传的一段数据，浏览器会自动保存，后面向
+ 主要作用是 识别用户身份如鉴权
  
## Session
+ 缺点是多服务器并不共享Session，当做负载均衡时
## Cookie和Session对比
+ Cookie是浏览器保存
## token 和 jwt

## Cookie/Session 和 token/jwt两种保存用户凭证的解决方案对比
+ token可以防csrf攻击，csrf攻击的原因是浏览器会自动带上cookie，而不会带上token
## 单点登录怎么实现
单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的SSO系统记录登录状态
用户登录跳转到Cas serve，即SSO登录系统，在SSO系统登录
登录认证后将登录状态写入SSO的session，浏览器中写入SSO域下的Cookie
SSO系统登录后生成一个Service Ticket然后跳转到A系统，将ST作为参数传递给A系统
A系统通过ST去验证是否有效，有效则将登录状态写入Session，并设置A系统域的Cookie
B系统登录依旧是跳到SSO系统，因为SSO系统已经登录了，直接返回ST
同样B系统将ST作为参数请求后台，验证有效后，将登录状态写入session，并在B系统域下写入cookie

## 常用请求方法
## 状态码
状态码  英文名     描述
200：OK：请求已成功，请求所希望的响应头或数据体将随此响应返回
202：Accepted  已接受请求，但未处理完成
206 Partial Content 部分内容，服务器成功处理了部分GET请求（断点续传）

### 3开头表示重定向
301 Moved Permanently 永久移动，请求的资源已被永久移动到新uri，返回信息会包括新的uri，浏览器会自动定向到新uri。
  后面的任何新的请求都应该使用新的uri代替
302 Found 临时移动
304 返回缓存在本机的内容

### 4开头表示服务器出了完成，但返回不符合预期的内容
400 Bad Request 客户端请求的语法错误，服务器无法立即
401 Unauthorized 请求要去用户的身份认证
403 Forbidden 服务器连接请求客户端的，但拒绝执行此请求
404 Not Found 服务器无法根据请求找到资源（网页）

## 5开头表示服务器内部处理流程出现异常
500 Internal Server Error 服务器内部错误，无法完成请求
502 Bad Gateway 网关或代理服务器出现异常，从远端服务器接收到一个无效请求
## 301和302对seo有什么影响
+ 301是永久性重定向，301响应默认情况会被缓存，搜索引擎在抓取新内容的同时也将旧的网站替换为重定向后的网站。使用场景：要使用新域名
+ 302是临时性重定向，，302响应默认不会缓存，并且302响应会影响到引擎优化效果，搜索引擎会抓取新的内容而保留旧的网址
