## 强缓存和协商缓存
强缓存：
+ 强缓存通过Cache-Control 和 Expires 两个字段实现
+ Expires是http1.0的，表示过期时间
+ Cache-Control是http1.1的，优先级高于Expires
  + request请求相关的缓存指令：
    + max-age：表示存活时间，单位s
    + no-cache：通过协商缓存决定是否使用缓存
    + no-store：所有内容都不会被缓存，包括强缓存和协商缓存
    + min-fresh：能够容忍的最小新鲜度，即 max-age + min-fresh时间内 可以使用缓存
    + max-stale：最大容忍时间，如果没有指定，则说明浏览器愿意接收任何age的响应
  + response响应相关的缓存指令：
    + no-cache
    + no-transform: 告诉中间代理不要改变资源的格式。中间代理有时会改变图片以及文件的格式来提高性能
    + public：客户端和代理服务器都可以缓存
    + private：只有客户端可以缓存
    + max-age
协商缓存：当没有命中强缓存，会发起请求到服务器，如果命中协商缓存则返回304和Not Modified。协商缓存通过Etag/If-None-Match，Last-Modified/If-Modified-Since这俩组实现对比。
  + Last-Modified指资源上次的更新时间，首次请求会返回并保存，下一次请求带上If-Modified-Since，值为Last-Modified，服务端进行比对 资源的更新时间，判断是否命中协商缓存。缺点是：保存的时间只具体到秒，但资源有可能在1s内多次更新
  + Etag是唯一标识的hash值，只要资源发生变化，Etag就会改变。下次请求就带上 If-None-Match：Etag。缺点是：性能较差，每次都要通过算法更新Etag
总结：强制缓存优先于协商缓存，若强制缓存生效则直接使用缓存，不生效则进行协商缓存。强制缓存 由Cache-Control 或 Expires 实现。协商缓存由 Etag/If-None-Match 和 Last-Modified/If-Modified-Since 实现。对于频繁变动的资源，使用协商缓存，对于不常变动的资源，使用强制缓存，如max-age设置很大的时间，然后通过增加版本号，更新资源。
### 缓存位置
缓存位置一般位于Memory cache（内存缓存），disk cache（磁盘缓存）
### 如何不使用缓存
+ Cache-Control：no-store
+ 改变资源的url，如增加版本号、hash值
### no-store和no-cache区别
+ no-store是完全禁止缓存
+ no-cache是协商缓存

## http1.1 与 http1.0区别
+ 缓存处理：1.1使用Etag/If-None-Match等更多缓存头来控制缓存，1.0使用last-modified、Expires
+ 长连接：1.1支持长连接，即在一个tcp连接可以传送多个http请求和响应，Connection：keep-alive
+ 错误状态管理：1.1增加了24个错误状态响应码
+ 其他：新增请求方式，put、delete、options
+ 1.1加入了管道化特性：即允许客户端在已发送的请求收到服务端响应之前发送下一个请求
## http1.1和1.0问题
+ 传输数据都是明文传送，安全性不足
+ 1.0基于tcp协议，要三次握手才能建立连接，每次传输数据都要重新建立连接
+ 1.1虽然支持了长连接，加入了管道化特性，但是还是解决不了队头阻塞问题。
  + 队头阻塞：每个请求响应必须等到前一个请求响应之后才能发送
+ 而且长连接也会影响性能，因为响应之后还保持了不必要的连接很长时间
## https 与 http1.1区别
+ https是由tls和http协议构建的可进行加密、身份认证的网络协议，比http更安全
+ https需要CA申请证书，大部分证书都需要交费
+ https对访问速度会有一定的降低，因为多了tls握手、大量的密钥算法计算等
## http2.0 新特性
+ 2.0的协议解析采用二进制格式传输数据，1.x是基于文本的，文本表现形式多样，需要考虑较多场景
+ 多路复用，所有请求都是通过一个tcp连接并发完成。因为数据流以消息形式发送，而消息由一个或多个帧组成，每个帧首部会有流的标识，所以多个帧可以乱序发送，通过帧的流标识重新组装
+ 服务端推送，允许服务端对客户端的一个请求发送多个响应，如浏览器只请求了index.html,服务器把index.html、style.css、png一起发送给浏览器，这样只需要一轮http通信，浏览器就得到了全部资源
+ header压缩，http2.0在客户端和服务端使用 首部表来缓存之前发送的键值对，对于相同的头部字段，后续的请求和响应不会重复发送，减小了头部的大小。1.x的header携带的内容过大，而且很多字段又是重复的，如Cookie，增加了传输的成本
+ 主流的浏览器只主持加密的http2
+ 兼容http1.1
## http2.0问题
+ 依旧是要经过tcp连接3次握手 和 tls 连接
+ tcp的队头阻塞并没有彻底解决。因为tcp有个丢包重传机制，http2.0出现丢包时，整个tcp都要开始等待重传，这样就阻塞到该tcp连接中的所有请求。而1.1因为可以开启多个tcp连接，丢包只会影响一个tcp连接
## http3.0
HTTP3.0的核心是QUIC协议，可以定义为基于UDP的安全可靠的HTTP2.0协议。
QUIC协议针对基于TCP和TLS的HTTP2.0协议，解决了几个问题
+ 减少了tcp三次握手和tls握手时间。基于UDP协议的QUIC，因为UDP本身没有连接的概念，连接建立时只需要一次交互的时间

## 怎么理解HTTP是无状态协议
+ HTTP是无状态协议，指对事物处理没有记忆能力，

