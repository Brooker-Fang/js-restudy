## 概要
理清执行上下文、作用域、环境记录、词法环境、变量环境这些概念的联系
## 执行上下文分为三类：
+ 当js执行全局代码时，会编译全局代码并创建 全局执行上下文，全局执行上下文只会创建一个
+ 当调用一个函数时，函数体内的代码会被编译，并创建函数执行上下文，一般情况，函数执行结束后，刚刚所创建的执行上下文 会被推出 js调用栈并销毁
+ 当使用eval函数时，eval的代码也会被编译，并创建执行上下文
全局执行上下文会创建全局环境记录，而函数执行上下文会创建时会同时创建This Binding、VariableEnvironment（变量环境组件）、LexicalEnvironment（词法环境组件）。全局环境记录、VariableEnvironment（变量环境组件）和LexicalEnvironment（词法环境组件）都是一种环境记录。
## 什么是环境记录
根据最新tc39规范文档看https://tc39.es/ecma262/#sec-environment-records
+ 环境记录 用于记录词法环境中的标识符与变量的映射，类似一个对象或者map。
+ 环境记录分为 声明式环境记录DeclarativeEnvironmentRecord、对象环境记录 ObjectEnvironmentRecord 和 全局环境记录 GlobalEnvironmentRecord
+ 每个环境记录都有一个outerEnv 字段，outerEnv可能为null（全局环境记录的outerEnv为null） 或者 是对外部环境记录的引用（就是由这个字段 形成的作用域链）
## 什么是声明式环境记录
+ 声明式环境记录 绑定了由包含在其范围内的声明定义的标识符集，即var、let、const、class、module、import 和function函数声明
+ 声明式环境记录 又分为 函数环境记录FunctionEnvironmentRecords 和 模块环境记录Module Environment Records
+ 函数环境记录 是声明式环境记录 用于表示函数的顶级范围，有Arguments对象，并且如果函数不是箭头函数，会提供this绑定

## 看一下全局环境记录长啥样
根据规范文档https://tc39.es/ecma262/#sec-global-environment-records，可以知道：
+ 全局环境记录 是声明式环境记录 和 对象式环境记录的组合
+ 对象式环境记录主要是存在全局环境记录 和 with创建的环境记录
那伪代码大致长这样：
```js
  GlobalEnvironmentRecords: {
    outerEnv: null, // 全局环境 的外部引用为null
    [[GlobalThisValue]]: // this的执行 如 window
    [[ObjectRecord]]: { // 即对象式环境记录ObjectEnvironmentRecord
      // 包含了全局下var、function、generator、async声明的标识符 还有其他内置对象 如Math、Date
      // 用全局对象（如window）作为绑定对象，所以在全局下用var、function...声明的变量可以通过window[变量名] 访问（或window.变量名）
      [变量名]: undefined
    }, 
    [[DeclarativeRecord]]:{ // 即声明式环境记录DeclarativeEnvironmentRecord
      // 除了var、function、generator、async声明的标识符保存在这里，如let、const
      [变量名]: uninitialized // 在编译阶段为uninitialized
    },
    [[varNames]]: // var、function、generator、async声明的标识符列表
  }
```

函数执行上下存在着 词法环境LexicalEnvironment 和 可变环境 VariableEnvironment这俩个组件,
LexicalEnvironment 和 VariableEnvironment都属于环境记录，
LexicalEnvironment是标识用于解析此执行上下文中的代码所做的标识符引用的环境记录。
VariableEnvironment是标识保存此执行上下文中由 VariableStatements 创建的绑定的环境记录。
可以理解为VariableEnvironment 保存着var声明的标识符，LexicalEnvironment则保存着let、const声明的标识符
```js
FunctionExecutionContext = {
  VariableEnvironment: {
    // 保存var声明的标识符
    outerEnv: GlobalExecutionContext // 外部环境记录
  },
  LexicalEnvironment: {
    // 保存let、const声明的标识符
    outerEnv: GlobalExecutionContext // 外部环境记录
    this: ...
    argument: {...}
  }
}
```
## 关系串联
+ 执行上下文 会创建环境记录
+ 词法环境 和 变量环境 都是环境记录 
+ 作用域链 即 词法环境链

## 词法作用域
+ JS 的作用域遵循的就是词法作用域模型，即静态作用域
+ 词法作用域 是指作用域是由代码中函数声明的位置来决定的
```js
  var str = 'global'
  function printStr() {
    console.log(str)
  }
  function test() {
    var str = 'text'
    printStr() // 打印 global，因为作用域由 函数声明的位置决定，所以consoleStr函数引用的外部环境是 全局环境，所以当前函数的词法环境没有str，就会查找外部环境记录，于是打印 global
    function innerPrint() {
      console.log(str)
    }
    innerPrint() // innerPrint的外部环境 指向 test函数的环境记录，所以打印 test
  }
  test()
 ```
## js引擎执行代码
+ 创建新的执行上下文
+ 将改执行上下文的变量环境组件和 词法环境组件 都指向新创建的词法环境
+ 将改执行上下文 推入 执行上下文栈，成为正在运行的执行上下文
+ 对该代码块的标识符进行实例化及初始化
+ 执行代码
+ 运行完后将该执行上下文出栈

## 块级代码实现原理
+ https://tc39.es/ecma262/#sec-block
+ 当执行到块级代码时，会让oladEnv成为正在运行的的执行上下文
+ 让blockEnv为新的声明式环境记录
+ 执行BlockDeclarationInstantiation，实例化blockEnv环境记录
+ 将运行执行上下文的 LexicalEnvironment 设置为 blockEnv
+ 令blockValue 是对StatementList 求值的结果。
+ 将运行执行上下文的 LexicalEnvironment 设置为 oldEnv。
+ 返回块值。