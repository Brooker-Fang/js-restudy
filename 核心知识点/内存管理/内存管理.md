## 垃圾回收机制 即GC算法
+ GC是一种机制，垃圾回收期完成具体的工作
+ 工作内容就是 查找垃圾释放空间、回收空间
+ 算法就是查找和回收所遵循的规则

## 常用GC算法
+ 引用计数
+ 标记清除
+ 标记整理
+ 分代回收

## 引用计数算法
核心思想：设置引用数，判断当前引用数是否为0。
当声明了一个变量并将一个引用类型值赋值给该变量，则该值的引用次数+1，如果同一个值又被赋给其他变量，引用次数+1。想法，如果取消了这个值的引用，则引用次数-1。当垃圾回收机制运行时，会回收引用数为0的值，并释放其内存
### 优点
+ 发现垃圾时立即回收
+ 当内存即将爆满时，垃圾回收器就会立马工作，最大限度减少程序暂停
### 缺点
+ 无法回收循环引用的对象
+ 时间开销大，当前引用计数器需要时刻监控引用值的修改，每次修改也要去维护引用数，增加时间开销

## 标记清除算法
核心思想：分标记和清除二个阶段完成，两次遍历实现垃圾回收
+ 标记阶段：遍历所有对象并标记活动对象
+ 清除阶段：遍历所有对象，清除没有标记对象

### 优点
可以解决函数内循环引用的对象

### 缺点
空间碎片化，即回收的空间不连续，不利于后续申请使用空间

## 标记整理算法
核心思想：亦是分为标记和清除两个阶段完成。
标记阶段和标记清除算法一样，区别在于清除阶段执行前，会先对标记的活动对象进行整理，移动引用值在内存中的位置，使活动对象在内存中的地址连续，这样在清除未被标记的值后，可以使释放的空间连续

## V8内存分配
V8内存空间一分为二
小空间用于存储新生代对象，大的空间存储老生代对象
新生代指的是存活时间较短的对象，比如函数内的变量
## V8垃圾回收策略
V8的内存是有上限的
+ 采用分代回收的思想
+ 内存分为新生代和老生代
+ 针对不同对象采用不同算法
### 新生代对象回收
回收过程采用复制算法和标记整理
+ 新生代内存区又分为两个等大小的内存空间，一个正在使用的空间From，一个空闲空间To
+ 活动对象都存于From空间
+ 当From触发GC机制时，会对From空间进行标记整理，即标记活动对象并移动
+ 标记整理后，将From空间的活动对象都复制到空闲空间To。
+ 在拷贝到To空间的过程中，可能出现晋升，即将新生代对象移动到老生代对象，而不是空闲空间
  + 晋升的条件：
    + 经过一轮GC回收后还存活的新生代需要晋升
    + 当空闲空间To的使用率超过25%
+ 然后回收释放From内的所有活动对象，变成了空闲空间
+ 这时原来的空闲空间就变成了使用空间，即To变为了From，From变为了To
### 老生代对象回收
老生代内存：在64位操作系统中有1.4G，32位操作系统有700M
回收主要采用标记清除、标记整理、增量标记算法。
+ 首先是采用标记清除完成垃圾空间的回收，这时会产生一些空间碎片
+ 当新生代对象出现晋升时，即新生代对象要拷贝到老生代对象存储区，但是老生代存储空间不足以存储时，这种情况下会先采用标记整理进行空间优化
+ 最后会采用增量标记 进行优化垃圾回收操作
  + 增量标记：当进行垃圾回收时，js会停止运行，而增量标记就是将垃圾回收的操作分为多个阶段，如对活动对象进行标记时，可以先标记一部分对象，然后去执行js，执行一段时间后再继续进行下一阶段的标记或者对标记进行清除。即将总的垃圾回收执行时间，分为一小段一小段的执行
## V8中常用的GC算法
+ 分代回收
+ 空间复制
+ 标记清除
+ 标记整理
+ 标记增量

## V8的垃圾回收是发生在什么时候
V8引擎实现自动的垃圾回收管理，利用浏览器渲染页面的空闲时间进行垃圾回收
