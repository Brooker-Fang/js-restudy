## 从输入url到页面展示完整流程示意图
+ 首先，浏览器进程接收到用户输入的url请求，浏览器进程便将该url转发给网络进程
+ 网络进程发起真正的url请求
+ 接着，网络进程接收到响应头数据，便解析响应头数据，并将数据转发给浏览器进程
+ 浏览器进程接收到网络进程的响应头数据之后，发送提交导航消息到渲染进程
+ 渲染进程接收到“提交导航”的消息之后，便开始准备接收html数据，接收数据的方式是直接和网络进程建立数据管道
+ 最后渲染进程会想浏览器进程确认提交，这是告诉浏览器进程，已经准备好接受和解析页面数据了
+ 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态
+ 用户发出url请求到也没开始解析的这个过程，就叫做导航


+ 用户输入，浏览器会判断地址栏上输入的是搜索内容还是请求的url
  + 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的url
  + 如果判断输入的内容符合url规则，那地址栏会根据规则，将这段内容加上协议，合成完整的url
  + 在进行url请求之前，会给当前页面一次执行beforeunload事件的机会
+ 浏览器进程会通过进程间通信把url请求发送至网络进程，网络进程接收到url请求后，会在这发起正在的uil请求流程
  + 网络进程会先查找本地缓存，有直接使用缓存资源，即判断是否命中了强制缓存，没有则进入网络请流程。
  + 网络请求流程前 要先进行dns解析获取ip地址，即进入dns解析过程：
    + 先查找浏览器的DNS缓存
    + 查找操作系统的dns缓存
    + 查找本地host文件
    + 查找本地dns服务器的dns缓存
    + 到根dns服务器查找，由根dns服务器告诉本地dns服务器 顶级dns服务器 的ip地址 (如返回.com的顶级域名服务器对应的ip地址)
    + 拿到顶级dns服务器ip地址后去查找，顶级dns服务器 会告诉 本地dns服务器 本地dns权威域名服务器的ip地址(如返回baidu.com的二级域名服务器对应的ip地址)
    + 拿到本地dns权威域名服务器后去查找，本地dns权威域名服务器 会将 最终的ip地址 返回给浏览器，整个dns解析过程结束(最终返回www.baidu.com的ip地址)
  + ip地址查找到后，则开始和服务器建立TCP连接
    + TCP连接前的三次握手：
    + 第一次握手，客户端发送标志位syn为1的包，服务器接收到后确认客户端发送正常 和自身接收能力正常。syn即sychronize 意为同步
    + 第二次握手，服务端发送syn-ack返回客户端，客户端确认服务端接收发送能力正常，自身的发送和接收能力也正常。ack即acknowledge，意为确认
    + 第三次握手，客户端ack发送服务端，服务接收到，确认了自身发送能力也正常，和客户端接收能力正常。
    + 至此，客户端和服务端都确认了自身 和 对方的接收发送能力都正常，可以开始进行数据传输了。
    + 所以3次握手主要是确认对端的接收发送能力都没问题
    + 前端性能优化即要减少tcp连接，因为3次握手的时间会带来性能损失
  + 如果请求协议是https，那么还需要建立TLS连接
  + 连接建立后，浏览器端会构建请求头、请求行和Cookie等数据附加到请求头，然后向服务器发送构建好的请求信息
  + 服务器接收到请求信息后，会根据请求信息生成响应数据，包括响应头、响应行、响应体等信息，并发给网络进程。网络进程接收后，就开始解析响应数据的内容了
  + 由于Chrome的页面渲染运行时在渲染进程中的，所以接下来就需要准备渲染进程了。
  + 接下来进行提交文档的流程，即浏览器进程将网络进程接收到的html数据提交给渲染进程
    + 具体流程：
      + 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的信息
      + 渲染进程接收到“提交文档”的消息后，会和网络进程简历传输数据的“管道”
      + 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
      + 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括安全状态、地址栏的url，前进后退的历史状态，并更新web页面
  + 文档被提交后，渲染进程开始页面解析和子资源加载。
  + 开始渲染流程：渲染流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成
    + 构建DOM树
      + 因为浏览器无法直接理解和使用html，所以需要将html转换为浏览器能够理解的结构——DOM树
      + HTML解析器将HTML解析为dom树，并保存在内存中。
      + HTML解析器并不是等整个文档加载完成后再解析的，而是网络进程加载了多少数据，HTML解析器就解析多少数据
      + 渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到的数据就一直往管道放，而渲染进程则从管道另一端不断读取数据，并同时将数据发给HTML解析器解析
        + HTML解析流程：即字节流转换为DOM需要三个阶段
          + 第一个阶段，通过分词器将字节流转换为Token
          + 后续的二阶段和三阶段是同步进行的，需要将Token解析为DOM节点，并将DOM节点添加到DOM树中，即document
    + 样式计算，计算出DOM节点中每个元素的具体样式，具体为以下三步：
      + 把CSS转换为浏览器能够理解的结构，即styleSheets，保存在document.styleSheets
      + 标准化样式表中的属性值，如em单位转换为px、颜色转换为rgb形式
      + 标准化后，开始计算dom树中每个节点的具体样式。
      + 计算好了节点的具体样式，就开始布局阶段
    + 布局阶段，即计算出dom树中可见元素的在浏览器的具体位置，具体过程：
      + 构建布局树：过滤掉不可见节点
        + 遍历dom树中的所有可见节点，并加入到布局树中
        + 而不可见的节点会被布局树忽略，如head下的全部内容，如具有display:none样式的元素
      + 布局计算：计算布局树节点的坐标位置
      + 布局阶段结束，有了布局树以及每个节点的坐标位置，
    + 分层：接下来渲染引擎还需要为特定的节点生成专用的图层，如复杂的 3D 变换、页面滚动、z-index z轴排序的节点，然后并生成图层树
      + 并不是每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层
      + 拥有层叠上下文属性的元素会被提升为单独的一层
      + 需要剪裁的地方也会被创建为图层，剪裁如overflow：hidden 被剪裁的内容为单独的一层，如果出现滚动条，滚动条也会被提升为单独的一层
      + 完成图层树的构建后，开始对每个图层进行绘制，开始进行图层绘制阶段
    + 为每个图层生成绘制列表：
      + 渲染引擎实现图层绘制，会将一个图层的绘制拆分为很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表
      + 组成待绘制列表后，主线程会把绘制列表提交给合成线程，最后的绘制操作是由渲染引擎中的合成线程来完成
    + 栅格化操作：即合成线程将图层分为图块，并在光栅化线程池中将图块转换为位图
      + 因为有些图层很大，但通过浏览器视口只能看到页面的很小一部分，所以合成线程会先将图层划分为图块
      + 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的，所谓栅格化，是指将图块装换为位图
      + 栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，生成的位图被保存在GPU内存中
      + GPU是另一个进程，这边涉及到了跨进程操作，即渲染进程把生成图块的指令发送给GPU，然后再GPU中执行生成图块的位图，并保存在GPU内存中
    + 合成绘制：
      + 合成线程发送绘制图块命令DrawQuad给浏览器进程
      + 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

## 重排
更新了元素的几何属性，如宽、高，重排需要更新完整的渲染流程，所以开销最大
## 重绘
更新了元素的绘制属性。如背景颜色，布局阶段不会重新执行，直接进入绘制阶段，相比于重排，重绘省去了布局和分层阶段
## 合成
如果更改了一个即不需要布局也不要绘制的属性，渲染引擎将跳过布局和绘制阶段，只执行后续的合成操作，这个过程就叫合成。如使用transform来实现动画效果
## js如何影响DOM树的构建的？
+ HTML解析器如果遇到 script 标签，会暂停DOM 的解析，如果是引人的js文件，则会先去下载js文件，在执行js代码，所以js文件的下载过程会阻塞DOM解析
+ 不过Chrome做了优化，如预解析操作，当渲染引擎收到字节流后，会开启一个预解析线程，用来分析HTML文件中包含的js、css等相关文件，预解析线程会提前下载这些文件
+ 引人js线程会阻塞DOM解析，可以做一些优化，如cdn来加速js文件的加载、压缩js文件提交，如果js文件中没有操作dom的相关代码，可以将js文件设置为异步加载，通过async或defer标记。async 加载完成会立即执行，defer需要在DOMContentLoaded事件之前执行